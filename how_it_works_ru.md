
### Предисловие
Исходя из реверса я решил что в сборке Dungeon Keeper 2 использовался компилятор `msvc` и все процессы пересборки затачиваю именно под него.
Со времен официальной сборки Dungeon Keeper 2 основные принципы стандартной компиляции не менялись.

Процесс компиляции `.cpp` исходных файлов в конечный `.exe` файл имеет промежуточный этап.
Сначала все `.cpp` файлы каждый в своем процессе однопоточно компилируется в `.obj` файлы компилятором `cl.exe`.
Для каждого `.dll` файла, с которым можно образовать связь, есть отдельный `.lib` файл.
После компиляции, линкер `link.exe` берет все скомпилированные `.obj` файлы и дополнительно подключенные `.lib` файлы и объединяет их всех в `.exe` файл если, все ссылки между `.obj` файлами были удовлетворены.

В случае стандартной компиляции, `.obj` файлы имеют формат `COFF` и содержат машинный код и глобальные(+статические) переменные,
который во время линковки не подвергается изменениям за исключением правки связей между функциями и данными.

В cовременной компиляции есть более продвинутые сценарии где используется `LTO`(Link Time Optimization).
В этом сценарии в `.obj` файлах хранится `IR`(Intermediate Representation) байткод вместо скомпилированного машинного кода.
Таким образом при линковке можно применять более эффективные оптимизации. но это не наш случай.

`.lib` файлы можно считать архивами, содержащими множество `.obj` файлов. При этом `.obj` файлы могут так же описывать зависимость от экспортированных символов какого либо `.dll` файла.
В `.cpp` файлах может быть объявлено множество функций и данных. Соответственно в одном `.obj` файле может находится множество функций и единиц данных.

В `.exe` файле хранится скомпилированный машинный код и данные.
Если собрать информацию о связях между функциями и данными, то можно попытаться вернуть их обратно в `.obj` файлы.
А затем перекомпилировать с изменениями.

### Используемые термины в проекте
Для каждой функции и единице данных в `.obj` файле создается массив байт и `IMAGE_SECTION_HEADER`, что его описывает.
У себя в коде такую единицу кода или данных я называю `Chunk`(tools/delinker/chunk/Chunk.h).
`Chunk` представляет собой массив байтов(Chunk::data) с информацией о том можно ли эти данные читать, писать и исполнять(Chunk::chars).
Так же `Chunk` хранит информацию о связях между чанками(Chunk::refs, Chunk::xrefs).

Известные функции и данные называются `Global`(mapping/sgmap/Global.h).
Каждый `Global` представляет собой разметку данных с детальной информацией о типе даных.
Настолько детальной что из них можно генерировать `cpp` заголовки.

Маппинг `Global` данных достается через реверс-инжиниринг в `Ida PRO`(mapping/ida/sgmap_ida.py).
Маппинг связей между `Chunk` объектами так же достается через реверс-инжиниринг в `Ida PRO`(mapping/ida/references_ida).
Увы, я пока не нашел способа синхронизировать в `git` между различными исследователями работу по реверсу.
Был вариант синхронизации через дамп `.idc`. К сожалению дамп `.idc` сохраняет типы, но не сохраняет древовидную структуру типов.

### Принцип работы
В `DKII.EXE` версии 1.7.0 находятся секции:
```
# access: R-read, W-write, X-execute
<va from>-<va to> <access> <name>
00401000-00652AA2 R-X .text
00653000-0066BE1A R-X cseg
0066C000-0068D53C R-- .rdata
0068E000-006CD190 RW- .data
006CD190-007A6DD0 RW- .data    uninitialized
007A7000-007A7730 RW- grpoly_d
007A8000-007ACACC RW- uva_data
007AD000-007AE658 RW- idct_dat
007AF000-007AFA00 RW- tqia_dat
007B0000-007B1004 RW- dseg
007B2000-007B2400 RW- lbmpeg_d
007B3000-007B5F30 R-- .rsrc
```
Каждую секцию я помещаю в `Chunk` и применяю собранные ранее связи между чанками из меппинга(mapping/references.map).
Этого уже достаточно, чтобы сформировать `.obj` файлы через сборщик(tools/delinker/CoffBuilder.cpp).
Но при линковке такой exe файл не заработает.
Для работы нужно вырезать импорты из `.rdata` и объявить их заново так, чтобы линкер связал их с существующими `.dll` в системе.
Так же нужно каким то образом вызвать точку вхождения программы и в теории exe заработает.
На этом этапе у нас получится 12 `.obj` файлов и каждый будет собран из одного `Chunk` объекта.
Но этого не достаточно, чтобы произвести подмену одной функции или одной глобальной переменной.

Следующим шагом я собираю `Global` объекты из маппинга(mapping/DKII_EXE_v170.sgmap) и используя эти объекты нарезаю `Chunk` объекты на части.
Так у нас получились нарезанные `Chunk` объекты каждый со своим именем с детализацией нарезки которой реверс-исследователи смогли добиться.

Для проведения подмены функций и данных необходимо исключить желаемые `Chunk` объекты из процесса делинковки при помощи маппинга(src/replace_globals.map).
Так у нас появятся недостающие функции и данные во время линковки и мы получим ошибку линковки.
После этого напишем их вручную с правильным именованием и добавим наши .cpp файлы к линковке.

Так мы получаем проект, с частично декомпилированным исходным кодом способный обратно компилировать его в рабочую `.exe`.
Изменение написанные исходных файлов не требует особых навыков, в отличие от точечных бинарных патчей.
Это и есть то удобство, которого я не мог достичь в проекте `Ember`.

