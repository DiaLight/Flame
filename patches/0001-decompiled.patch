From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DiaLight <light_01@rambler.ru>
Date: Thu, 11 Jul 2024 03:07:33 +0300
Subject: [PATCH] decompiled


diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,49 @@
+set(TARGET dkii_flame)
+
+add_executable(${TARGET}
+        main.cpp
+        dkii_exe_functions.cpp
+        dk2/MyResources.cpp
+        dk2/MyGame.cpp
+        dk2/MyDxMouse.cpp
+        ${DKII_RESOURCES_FILE}
+        )
+target_compile_definitions(${TARGET} PRIVATE
+        DIRECTINPUT_VERSION=0x0500
+        DIRECT3D_VERSION=0x0600
+        )
+target_link_libraries(${TARGET} PRIVATE
+        dkii_delinked dkii_exe_api
+#        gog_patch_dll
+
+        # dk2 specific libs
+        qmixer_genlib  # generated in qmixer_dll/genlib
+        weanetr_genlib  # generated in weanetr_dll/genlib
+
+        # the others libs dk2 depends on
+        winmm
+        dinput_genlib  # generated in dinput_dll/genlib
+        ddraw  # patch - dont link against gog's PATCH.dll because patch addresses are change after recompilation
+        # also i fully decompiled gog's PATCH.dll and bundled in project
+
+        imm32
+        # wsock32 is old link target
+        ws2_32 # should be better
+        dsound
+        )
+
+target_compile_options(${TARGET} PRIVATE
+        /Gy  # Enable Function-Level Linking
+        /Gw  # Optimize Global Data
+        /GS-
+        /Gz  # use __stdcall by default
+        )
+target_link_options(${TARGET} PRIVATE /OPT:NOREF)
+target_link_options(${TARGET} PRIVATE /MAP)  # generate msvc mapping file for exe
+set_property(TARGET ${TARGET} PROPERTY
+        MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
+set_target_properties(${TARGET} PROPERTIES OUTPUT_NAME
+        "DKII-Flame${OUTPUT_SUFFIX}"
+)
+
+
diff --git a/dk2/MyDxMouse.cpp b/dk2/MyDxMouse.cpp
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/dk2/MyDxMouse.cpp
@@ -0,0 +1,53 @@
+//
+// Created by DiaLight on 09.07.2024.
+//
+#include <ntstatus.h>
+#define UMDF_USING_NTSTATUS
+#include "dk2/MyDxMouse.h"
+#include "dk2/MyDxInputManagerCb.h"
+#include "dk2_functions.h"
+
+int *dk2::MyDxInputManagerCb::initMouse(int *pstatus) {
+    if (this->f58_pdxmouse) {
+        *pstatus = 0xCFFE0102;
+        return pstatus;
+    }
+    int status;
+    MyDxMouse_create(&status, &this->f58_pdxmouse);
+    if (FAILED(status)) {
+        *pstatus = status;
+        return pstatus;
+    }
+    this->fC_async.setObjAndSignal(&status, (uint32_t *) this->f58_pdxmouse);
+    if (FAILED(status)) {
+        *pstatus = status;
+        return pstatus;
+    }
+    this->f58_pdxmouse->setControlKeysUpdater(this->f5C_controlKeys);
+    this->f58_pdxmouse->dx_device.updateCoopLevel_acquire(&status);
+    *pstatus = STATUS_SUCCESS;
+    return pstatus;
+}
+
+int *__cdecl dk2::MyDxMouse_create(int *pstatus, MyDxMouse **pObj) {
+    if (pObj == nullptr) {
+        *pstatus = 0x80004003;
+        return pstatus;
+    }
+    MyDxMouse *obj = (MyDxMouse *) operator new(0x5Cu);
+    if (obj == nullptr) {
+        *pstatus = 0xCFFE0100;
+        return pstatus;
+    }
+    obj->constructor();
+    HRESULT result;
+    obj->initDevice_0(&result);
+    if (FAILED(result)) {
+        obj->v_scalar_destructor(1);
+        *pstatus = result;
+        return pstatus;
+    }
+    *pObj = obj;
+    *pstatus = STATUS_SUCCESS;
+    return pstatus;
+}
diff --git a/dk2/MyGame.cpp b/dk2/MyGame.cpp
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/dk2/MyGame.cpp
@@ -0,0 +1,177 @@
+//
+// Created by DiaLight on 08.07.2024.
+//
+#include "dk2/MyGame.h"
+#include "dk2/utils/Pos2i.h"
+#include "dk2/utils/AABB.h"
+#include "dk2/DxDeviceInfo.h"
+#include "dk2/DxModeInfo.h"
+#include "dk2_globals.h"
+#include "dk2_functions.h"
+
+int dk2::MyGame::prepareScreenEx(
+        uint32_t dwWidth,
+        uint32_t dwHeight,
+        uint32_t dwRGBBitCount,
+        int isWindowed,
+        int screenSwap,
+        int screenHardware3D) {
+    int sel_dd_idx = this->selected_dd_idx;
+    if (sel_dd_idx != this->last_selected_dd_idx) {
+        MyResources_instance.video_settings.sub_566E40(sel_dd_idx);
+        MyResources_instance.video_settings.sub_566F40(0);
+        MyResources_instance.video_settings.sub_566EC0(0);
+        if (isGameWindowCreated == 1) {
+            setDebugStringFun(debugMsgBox);
+            this->zbufferSurf = 0;
+            this->c_window_test.recreate();
+            IDirect3D2 *f6D_pIDirect3D2 = this->pIDirect3D2;
+            if (f6D_pIDirect3D2) {
+                f6D_pIDirect3D2->Release();
+                this->pIDirect3D2 = 0;
+            }
+            uint32_t status;
+            dk2wnd_cleanup(&status);
+            BullfrogWindow_destroy();
+            isGameWindowCreated = 0;
+        }
+        int result = this->createWindow(0);
+        if (!result)
+            return result;
+    }
+    int last_selected_dd_idx = this->last_selected_dd_idx;
+    int ddraw_idx;
+    DxDeviceInfo *v13;
+    int f1FE_modeListCount;
+    if (last_selected_dd_idx >= ddraw_device_count
+        || (ddraw_idx = 0,
+            v13 = &ddraw_devices[last_selected_dd_idx],
+            f1FE_modeListCount = v13->modeListCount,
+            f1FE_modeListCount <= 0)) {
+        LABEL_14:
+        MyGame_debugMsg(this, "Screen Mode %d*%d (%d bpp) is not available\n", dwWidth, dwHeight, dwRGBBitCount);
+        return 0;
+    }
+    DxModeInfo *f206_modeList = v13->modeList;
+    while (f206_modeList->dwWidth != dwWidth
+           || f206_modeList->dwHeight != dwHeight
+           || f206_modeList->dwRGBBitCount != dwRGBBitCount) {
+        ++ddraw_idx;
+        ++f206_modeList;
+        if (ddraw_idx >= f1FE_modeListCount)
+            goto LABEL_14;
+    }
+    void (__cdecl **fE89_WM_ACTIVATE_callbacks)(int, uint32_t, uint32_t, void *);
+    fE89_WM_ACTIVATE_callbacks = this->WM_ACTIVATE_callbacks;
+    int left = 8;
+    void (__cdecl **callbacks)(int, uint32_t, uint32_t, void *);
+    callbacks = this->WM_ACTIVATE_callbacks;
+    do {
+        if (*fE89_WM_ACTIVATE_callbacks)
+            (*fE89_WM_ACTIVATE_callbacks)(2, 0, 0, fE89_WM_ACTIVATE_callbacks[8]);
+        ++fE89_WM_ACTIVATE_callbacks;
+        --left;
+    } while (left);
+    setDebugStringFun(debugMsgBox);
+    int screenHardware3D_ = screenHardware3D;
+    bool isFullscreen = isWindowed == 0;
+    int screenSwap_ = screenSwap;
+    this->zbufferSurf = 0;
+    int initFlags;
+    if (isFullscreen) {
+        if (screenSwap_) {
+            initFlags = 1;
+            if (screenHardware3D_)
+                initFlags = 0x49;
+        } else {
+            initFlags = 2;
+            if (screenHardware3D_)
+                initFlags = 0x4A;
+        }
+    } else if (screenSwap_) {
+        initFlags = 0x11;
+    } else {
+        initFlags = 0x10;
+        if (screenHardware3D_)
+            initFlags = 0x58;
+    }
+    if (!cmd_flag_NOSOUND && MySound_ptr->v_sub_567210())
+        MySound_ptr->v_fun_5677D0();
+    this->c_window_test.recreate();
+    int dwHeight_;
+    int dwRGBBitCount_;
+    if (isWindowed) {
+        dwHeight_ = dwHeight;
+        AABB aabb;
+        aabb.minX = 50;
+        aabb.minY = 50;
+        aabb.maxX = dwWidth + 50;
+        aabb.maxY = dwHeight + 50;
+        if (*this->c_window_test.probably_do_show_window_ev0_7(&dwHeight, &aabb) < 0)
+            return 0;
+        dwRGBBitCount_ = dwRGBBitCount;
+    } else {
+        dwRGBBitCount_ = dwRGBBitCount;
+        int status;
+        if (*dk2dd_init(&status, dwWidth, dwHeight, dwRGBBitCount, initFlags, 0) < 0) {
+            process_win_inputs();
+            if (*dk2dd_init(&status, dwWidth, dwHeight, dwRGBBitCount_, initFlags, 0) < 0)
+                return 0;
+        }
+        dwHeight_ = dwHeight;
+    }
+    if (!cmd_flag_NOSOUND) {
+        if (MySound_ptr->v_sub_567210())
+            MySound_ptr->v_fun_5677E0();
+        else
+            MySound_ptr->v_set_number_of_channels(
+                    MyResources_instance.obj_29CB.numberOfChannels);
+        MyResources_instance.obj_29CB.resolveValues();
+    }
+    int screenSwap__1 = screenSwap;
+    this->isWindowed = isWindowed;
+    this->dwWidth = dwWidth;
+    this->dwHeight = dwHeight_;
+    this->dwRGBBitCount = dwRGBBitCount_;
+    this->_prepareScreen_a6 = screenSwap__1;
+    this->_prepareScreen_a7 = screenHardware3D_;
+    this->f18 = 0;
+    this->collect3dDevices();
+    this->f4C_.fun_559820(0);
+    setDebugStringFun(MyGame_static_559050_parse);
+    if (MyResources_instance.video_settings.zbuffer_bitnes == 16) {
+        if (!this->createZBufferSurf(0x10u) && !this->createZBufferSurf(0x20u))
+            this->createZBufferSurf(0x18u);
+    } else if (MyResources_instance.video_settings.zbuffer_bitnes == 32
+               && !this->createZBufferSurf(0x20u)
+               && !this->createZBufferSurf(0x18u)) {
+        this->createZBufferSurf(0x10u);
+    }
+    // move mouse to center
+    int mousePos_y = (unsigned int) this->dwHeight >> 1;
+    Pos2i mousePos;
+    mousePos.x = (unsigned int) this->dwWidth >> 1;
+    mousePos.y = mousePos_y;
+    MyInputManagerCb_static_setMousePos(&mousePos);
+    // direct invoke mouse updater
+    AABB updateMousePos;
+    updateMousePos.minX = 0;
+    updateMousePos.minY = 0;
+    updateMousePos.maxX = dwWidth;
+    updateMousePos.maxY = dwHeight_;
+    MyInputManagerCb_static_updateMouse(&updateMousePos);
+    void (__cdecl **callbacks_)(int, uint32_t, uint32_t, void *); // esi
+    callbacks_ = callbacks;
+    int left2 = 8;
+    do {
+        if (*callbacks_)
+            (*callbacks_)(3, 0, 0, callbacks_[8]);
+        ++callbacks_;
+        --left2;
+    } while (left2);
+    MyResources_instance.video_settings.sub_566F40(0);
+    MyResources_instance.video_settings.sub_566EC0(1);
+    HWND HWindow = getHWindow();
+    ij_ImmAssociateContext(HWindow, 0);
+    return 1;
+}
diff --git a/dk2/MyResources.cpp b/dk2/MyResources.cpp
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/dk2/MyResources.cpp
@@ -0,0 +1,71 @@
+//
+// Created by DiaLight on 08.07.2024.
+//
+#include "dk2/MyResources.h"
+#include "dk2_functions.h"
+#include "dk2_globals.h"
+
+
+dk2::MyResources *dk2::MyResources::init_resources() {
+    this->meshesFileMan.constructor();
+    int v9 = '\b';
+    this->devMeshesFileMan.constructor();
+    this->engineTexturesFileMan.constructor();
+    this->textureFileMan.constructor();
+    this->editorFileMan.constructor();
+    this->paletteFileMan.constructor();
+    this->spriteFileMan.constructor();
+    this->textsFileMan.constructor();
+    this->pathsFileMan.constructor();
+    this->frontEndFileMan.constructor();
+    this->f0 = '\0';
+    v9 = (uint8_t) 9;
+    char exeDir[260];
+    _strcpy(exeDir, "D:\\DEV\\DK2\\");
+    char *CommandLineA = GetCommandLineA();
+    char *cmdl = CommandLineA;
+    char *str_end;
+    if (*CommandLineA == '"') {
+        cmdl = CommandLineA + 1;
+        str_end = strchr(CommandLineA + 1, '"');
+        goto LABEL_5;
+    }
+    str_end = strchr(CommandLineA + 1, ' ');
+    if (!str_end) {
+        str_end = &cmdl[strlen(cmdl)];
+        LABEL_5:
+        if ( !str_end ) goto LABEL_12;
+    }
+    if (str_end > cmdl) {
+        do {
+            if ( *str_end == '\\' ) break;
+            --str_end;
+        } while( str_end > cmdl );
+        if (str_end > cmdl) str_end[1] = '\0';
+    }
+    _strcpy(exeDir, cmdl);
+    LABEL_12:
+    MyGame_debugMsg(&MyGame_instance, "HD Path: %s\n", exeDir);
+    _strcpy(this->executableDir, exeDir);
+    this->resolveMovies();
+    sprintf(this->editorDir, "%sdata\\editor\\", this->executableDir);
+    sprintf(this->savesDir, "%sdata\\Save\\", this->executableDir);
+    sprintf(this->settingsDir, "%sdata\\Settings\\", this->executableDir);
+    sprintf(this->globalDir, "GLOBAL\\");
+    sprintf(this->textsDir, "%sdata\\Text\\", this->executableDir);
+    sprintf(this->textureCacheDir, "%s\\Dk2TextureCache", this->executableDir);
+    sprintf(this->soundSfxDir, "%sdata\\sound\\SFX\\", this->executableDir);
+    sprintf(this->soundMusicDir, "%sdata\\sound\\Music\\", this->executableDir);
+    uint32_t status;
+    CFileManager_readAndParseWad(&status, &this->meshesFileMan, "%sdata\\Meshes.Wad", this->executableDir);
+    CFileManager_readAndParseWad(&status, &this->devMeshesFileMan, "K:\\DK2\\Dev\\Data\\Meshes.Wad", this->executableDir);
+    CFileManager_readAndParseWad(&status, &this->engineTexturesFileMan, "%sdata\\EngineTextures.wad", this->executableDir);
+    CFileManager_readAndParseWad(&status, &this->spriteFileMan, "%sdata\\Sprite.Wad", this->executableDir);
+    CFileManager_readAndParseWad(&status, &this->frontEndFileMan, "%sdata\\FrontEnd.wad", this->executableDir);
+    CFileManager_readAndParseWad(&status, &this->pathsFileMan, "%sdata\\Paths.wad", this->executableDir);
+    CFileManager_setPathFormat(&status, &this->editorFileMan, "%sdata\\editor", this->executableDir);
+    CFileManager_setPathFormat(&status, &this->textsFileMan, "%sdata\\text\\", this->executableDir);
+    CFileManager_setPathFormat(&status, &this->textureFileMan, "%sdata\\Texture", this->executableDir);
+    CFileManager_setPathFormat(&status, &this->paletteFileMan, "%sdata\\palette", this->executableDir);
+    return this;
+}
diff --git a/dkii_exe_functions.cpp b/dkii_exe_functions.cpp
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/dkii_exe_functions.cpp
@@ -0,0 +1,98 @@
+//
+// Created by DiaLight on 01.07.2024.
+//
+#include "dk2/MyGame.h"
+#include "dk2/MyDxInputState.h"
+#include "dk2/MyMouseUpdater.h"
+#include "dk2_functions.h"
+#include "dk2_globals.h"
+#include <windowsx.h>
+
+int32_t dk2::MyGame::isOsCompatible() {
+    return !isOsVersionGE(6, 0, 0);
+}
+
+void dk2::resolveDk2HomeDir() {
+    const char *CommandLineA = GetCommandLineA();
+    _strncpy(pathBuf, CommandLineA, 259u);
+    char firstChar = pathBuf[0];
+    pathBuf[259] = 0;
+    char sepChar = ' ';
+    if ( pathBuf[0] == '"' ) {
+        signed int idx = 0;
+        sepChar = '"';
+        unsigned int len = strlen(pathBuf) + 1;
+        if ( (int)(len - 1) > 0 ) {
+            do {
+                pathBuf[idx] = pathBuf[idx + 1];
+                ++idx;
+            } while ( idx < (int)(len - 1) );
+            firstChar = pathBuf[0];
+        }
+    }
+    char *pos = pathBuf;
+    if ( firstChar ) {
+        char curChar = firstChar;
+        do
+        {
+            if ( curChar == sepChar )
+                break;
+            curChar = *++pos;
+        }
+        while ( curChar );
+    }
+    *pos = 0;
+    char *sep1Pos = strrchr(pathBuf, '/');
+    char *sep2Pos = strrchr(pathBuf, '\\');
+    char **pSepPos = &sep2Pos;
+    if ( sep2Pos <= sep1Pos ) pSepPos = &sep1Pos;
+    char *sepPos = *pSepPos;
+    if ( sepPos ) {
+        sepPos[1] = 0;
+        setExeDirPath(pathBuf);
+    }
+}
+
+
+namespace dk2 {
+    enum GameActionKind : DWORD {
+        GA_ExitToWindows = 0x7D
+    };
+}
+
+namespace {
+    dk2::Pos2i clientSize;
+}
+
+LRESULT dk2::CWindowTest_proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) {
+    switch(Msg) {
+        case WM_ACTIVATE:
+            g_isNeedBlt_fullscr = wParam != 0;
+            break;
+        case WM_SYSCOMMAND: {
+            switch ( wParam ) {
+                case 0xF090u:
+                case 0xF093u:
+                case 0xF100u:
+                case 0xF160u:
+                case 0xF163u:
+                    return 0;
+                default:
+                    break;
+            }
+            break;
+        }
+        case WM_MOUSEMOVE: {
+            Pos2i pos;
+            pos.x = LOWORD(lParam);
+            pos.y = HIWORD(lParam);
+            MyInputManagerCb_static_setMousePos(&pos);
+            break;
+        }
+    }
+    if ( !getCustomDefWindowProcA() )
+        return DefWindowProcA(hWnd, Msg, wParam, lParam);
+    typedef LRESULT (__stdcall *CustomDefWindowProcA_t)(HWND, UINT, WPARAM, LPARAM);
+    auto CustomDefWindowProcA = (CustomDefWindowProcA_t) getCustomDefWindowProcA();
+    return CustomDefWindowProcA(hWnd, Msg, wParam, lParam);
+}
diff --git a/main.cpp b/main.cpp
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/main.cpp
@@ -0,0 +1,206 @@
+//
+// Created by DiaLight on 19.06.2024.
+//
+#include "dk2_functions.h"
+#include "dk2_globals.h"
+#include "dk2/MyMutex.h"
+
+namespace dk2 {
+
+    bool dk2_main1(int argc, LPCSTR *argv);
+    bool dk2_main2();
+
+}
+
+bool dk2::dk2_main2() {
+    MyGame_instance.f28D = cmd_flag_NOERRORS;
+    if ( MyResources_instance.video_settings.f9C )
+        MyResources_instance.video_settings.sub_566DA0();
+    if ( !cmd_flag_NOSOUND
+         && !MySound_ptr->v_sub_567210()
+         && !MySound_ptr->v_set_number_of_channels(
+            MyResources_instance.obj_29CB.numberOfChannels) ) {
+        MySound_ptr->v_fun_567410();
+        cmd_flag_NOSOUND = 1;
+    }
+    if ( cmd_flag_NOSOUND || CSpeechSystem_instance.sub_567F90() ) {
+        if ( !WeaNetR_instance.init() ) {
+            WeaNetR_instance.sub_559CB0();
+            if ( !cmd_flag_NOSOUND ) {
+                MySound_ptr->v_fun_567410();
+                CSpeechSystem_instance.sub_568020();
+            }
+            return false;
+        }
+        if ( !MyGame_instance.isOsCompatible() ) {
+            WeaNetR_instance.sub_559CB0();
+            if ( !cmd_flag_NOSOUND ) MySound_ptr->v_fun_567410();
+            return false;
+        }
+        if ( !all_components_fillStaticListeners() ) {
+            WeaNetR_instance.sub_559CB0();
+            if ( !cmd_flag_NOSOUND ) MySound_ptr->v_fun_567410();
+            return false;
+        }
+        if ( MyResources_instance.f2B2B ) {
+            MyResources_instance.useFe = 1;
+            MyResources_instance.f2A13 = 3;
+        } else if ( MyResources_instance.f2B2F == 1 ) {
+            MyResources_instance.useFe = 4;
+            MyResources_instance.f2A13 = 3;
+        } else if ( !cmd_flag_FrontEnd3D_unk8 ) {
+            if ( MyGame_instance.sub_559790() < 240.0 && getDevIdxSupportsLinearPerspective() != -1
+                 || MyGame_instance.sub_559790() < 290.0 && getDevIdxSupportsLinearPerspective() == -1 )
+            {
+                MyResources_instance.f2B77 = 1;
+            }
+            MyResources_instance.useFe3d = 1;
+            MyResources_instance.useFe = 5;
+            wcsncpy(MyResources_instance.f2A17, L"FrontEnd3DLevel", 0x40u);
+            MyResources_instance.f2A17[63] = 0;
+            MyResources_instance.f2B1B = 0;
+            MyResources_instance.f2A13 = 3;
+            cmd_flag_FrontEnd3D_unk7 = 1;
+        }
+        CGameComponent *cur = &CGameComponent_instance;
+        while (cur != nullptr) {
+            if (!cur->v_handle()) break;
+            CGameComponent *next = cur->v_mainGuiLoop();
+            cur->v_f10_();
+            cur = next;
+        }
+        all_components_clearStaticListeners();
+        WeaNetR_instance.sub_559CB0();
+        CSpeechSystem_instance.sub_568020();
+        if ( !cmd_flag_NOSOUND )
+            MySound_ptr->v_fun_567410();
+    }
+    return true;
+}
+bool dk2::dk2_main1(int argc, LPCSTR *argv) {
+    CoInitialize(0);
+    int status_2;
+    setLibIconName(&status_2, 1000);
+    struct _MEMORYSTATUS memoryStatus;
+    memset(&memoryStatus, 0, sizeof(memoryStatus));
+    cmd_flag_NOSOUND = 0;
+    memoryStatus.dwLength = 32;
+    GlobalMemoryStatus(&memoryStatus);
+    if ( memoryStatus.dwAvailPhys + memoryStatus.dwAvailPageFile >= 0x12C00000 ) {
+        if ( memoryStatus.dwAvailPhys + memoryStatus.dwAvailPageFile < 0x15E00000 )
+            g_fontType = 1;
+    } else {
+        g_fontType = 2;
+    }
+    int status;
+    struct _WIN32_FIND_DATAA FindFileData;
+    findFile(&status, *argv, &FindFileData, -1);
+    if (status >= 0) {
+        g_fileChecksum = FindFileData.ftLastWriteTime.dwLowDateTime + FindFileData.ftLastWriteTime.dwHighDateTime;
+        char *exeFilePath = (char *) argv[0];
+        uint32_t hashsum_ = 0x5041554C;
+        uint32_t hashsum = 0x5041554C;
+        int status2;
+        TbDiscFile *pTbDiscFile;
+        if (*MyDiscFile_create(&status2, &pTbDiscFile, exeFilePath, 0x80000001) >= 0 ) {
+            int sizeLeft_ = TbDiscFile_getSize(pTbDiscFile);
+            int sizeLeft = sizeLeft_;
+            if ( sizeLeft_ > 0 ) {
+                char buf[8192];
+                while (true) {
+                    int blockSize = sizeLeft_;
+                    if ( sizeLeft_ <= 0x2000 )
+                        memset(buf, 0, sizeof(buf));
+                    else
+                        blockSize = 0x2000;
+                    if ( (int)*TbDiscFile_readBytes(&status_2, pTbDiscFile, buf, blockSize, 0) < 0 ) {
+                        hashsum_ = 0;
+                        hashsum = 0;
+                        sizeLeft = 0;
+                    } else {
+                        DWORD *pos = (DWORD *) buf;
+                        sizeLeft -= blockSize;
+                        int dwordsCount = (blockSize + 3) / 4;
+                        if (dwordsCount > 0 ) {
+                            do {
+                                hashsum = _rotl(hashsum, 1);
+                                hashsum_ = *pos++ ^ hashsum;
+                                --dwordsCount;
+                                hashsum = hashsum_;
+                            } while(dwordsCount);
+                        }
+                    }
+                    if (sizeLeft <= 0) break;
+                    sizeLeft_ = sizeLeft;
+                }
+            }
+            int status_;
+            TbDiscFile_delete(&status_, pTbDiscFile);
+        }
+        g_fileHashsum = hashsum_;
+        closeFindFile(&status_2, (int)&FindFileData);
+    }
+    MyResources_instance.sub_55B120();
+    if ( !parse_command_line(argc, argv) || !loadResources() ) return false;
+    bool useDefaultWindowName = true;
+    unsigned __int8 *MbString = MyMbStringList_idx1091_getMbString(42u);  // "Dungeon Keeper II"
+    if ( MBToUni_convert(MbString, g_wchar_buf, 512) && unicodeToUtf8(g_wchar_buf, temp_string, 512) ) {
+        int status_;
+        setWindowName(&status_, temp_string);
+        useDefaultWindowName = false;
+    }
+    if (useDefaultWindowName) {
+        int status_;
+        setWindowName(&status_, "Bullfrog Productions Ltd");
+    }
+    int DevIdxSupportsLinearPerspective = getDevIdxSupportsLinearPerspective();
+    if ( (MyGame_instance.f50D & 0x800000) == 0 && DevIdxSupportsLinearPerspective == -1 ) {
+        unsigned __int8 *mbString1 = MyMbStringList_idx1091_getMbString(2u);
+        wchar_t wString1[512];
+        if (MBToUni_convert(mbString1, wString1, 512)) {
+            unsigned __int8 *mbString2 = MyMbStringList_idx1091_getMbString(0xB60u);
+            wchar_t wString2[512];
+            if (MBToUni_convert(mbString2, (wchar_t *)wString2, 512)) {
+                WCHAR Text[512];
+                dk2::_swprintf(Text, L"%s\n\n%s", wString1, wString2);
+                HWND HWindow = getHWindow();
+                MessageBoxW(HWindow, Text, g_wchar_buf, 0x10u);
+                return false;
+            }
+        }
+    }
+    bool success = MyGame_instance.init() && dk2_main2();
+    MyGame_instance.release();
+    releaseResources();
+    CoUninitialize();
+    return success;
+}
+
+int __cdecl dk2::dk2_main(int argc, LPCSTR *argv) {
+    uint32_t finalStatus = 0;
+    MyMutex mutex;
+    mutex.constructor("DKII MUTEX");
+    if (!mutex.alredyExists ) {
+        if(!dk2_main1(argc, argv)) {
+            finalStatus = -1;
+            mutex.destroy();
+            return 0;
+        }
+    }
+
+    finalStatus = -1;
+    mutex.destroy();
+    return 0;
+}
+
+int dk2::WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, CHAR *lpCmdLine, int nShowCmd) {
+    setHInstance(hInstance);
+    return dk2_main(g_argc, g_argv);
+}
+
+int main() {
+    // call entry point of DKII.EXE,
+    // initialize its runtime and call dk2::WinMain
+    dk2::dk2_start();
+}
+
diff --git a/replace_globals.map b/replace_globals.map
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/replace_globals.map
@@ -0,0 +1,26 @@
+# va comment
+
+006477F0 int WinMain(HINSTANCE, HINSTANCE, CHAR *, int);  /* auto */
+005A5DA0 int __cdecl dk2_main(int, const CHAR **);      /* auto */
+005B74A0 void resolveDk2HomeDir();  // ---------------  /* auto */
+005BC760 int *__cdecl MyDxMouse_create(int *, MyDxMouse **);  /* auto */
+
+
+# CWindowTest.h
+00556650 LRESULT CWindowTest_proc(HWND, uint32_t, WPARAM, LPARAM);  /* auto */
+00556704 extern void *jpt_5566AF[6];  // -------------  /* auto */
+0055671C extern uint8_t idt_5566A9[212];  // ---------  /* auto */
+
+# MyGame.h
+00557FB0 int isOsCompatible();  // -------------------  /* auto */
+005581B0 int prepareScreenEx(uint32_t, uint32_t, uint32_t, int, int, int);  /* auto */
+
+# MyResources.h
+0055C020 MyResources *init_resources();  // ----------  /* auto */
+
+# MyInputManagerCb.h
+# 005BB1C0 int *initMouse(int *);  // ------------------  /* auto */
+
+# MyDxInputManagerCb.h
+005BC060 int *initMouse(int *);  // ------------------  /* auto */
+
diff --git a/replace_structs.map b/replace_structs.map
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/replace_structs.map
@@ -0,0 +1,2 @@
+# not implemented
+
